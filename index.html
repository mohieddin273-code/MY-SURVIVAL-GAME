<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knight Survivor - AAA EDITION</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0033 50%, #330066 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial Black', Arial, sans-serif;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            background: #000;
            border: 10px solid;
            border-image: linear-gradient(45deg, #ffd700, #ff00ff, #00ffff, #ffd700) 1;
            border-radius: 25px;
            box-shadow: 0 0 100px rgba(255, 215, 0, 0.9), inset 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            max-width: 1200px;
            max-height: 900px;
        }
        
        canvas { 
            display: block; 
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
        }
        
        /* Motion Blur Canvas */
        #motionBlurCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.7;
            width: 100%;
            height: 100%;
        }
        
        /* Performance Stats */
        #fpsCounter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            color: #0f0;
            z-index: 999;
        }
        
        /* UI Elements with glassmorphism */
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            z-index: 10;
            pointer-events: none;
            flex-wrap: wrap;
        }
        
        .stat-group { 
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
        }
        
        .stat {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 0, 60, 0.8));
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 15px;
            border: 4px solid;
            border-image: linear-gradient(45deg, #ffd700, #ff00ff) 1;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.9), inset 0 2px 10px rgba(255,255,255,0.1);
            text-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700;
            min-width: 140px;
            animation: statGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes statGlow {
            from { box-shadow: 0 8px 25px rgba(0, 0, 0, 0.9), inset 0 2px 10px rgba(255,255,255,0.1); }
            to { box-shadow: 0 8px 35px rgba(255, 215, 0, 0.5), inset 0 2px 15px rgba(255,255,255,0.2); }
        }
        
        .stat-label {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-right: 6px;
        }
        
        /* Health/XP Bars */
        #healthBar, #xpBar, #shieldBar {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 450px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 0, 60, 0.9));
            backdrop-filter: blur(10px);
            border: 5px solid;
            border-image: linear-gradient(45deg, #ffd700, #ff00ff) 1;
            border-radius: 30px;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
        }
        
        #healthBar { height: 35px; bottom: 200px; }
        #xpBar { height: 22px; bottom: 150px; }
        #shieldBar { height: 22px; bottom: 110px; display: none; }
        
        #healthFill, #xpFill, #shieldFill {
            height: 100%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 0 0 10px #000, 0 0 20px #000;
            position: relative;
            overflow: hidden;
            font-size: 14px;
        }
        
        #healthFill { 
            background: linear-gradient(90deg, #ff0066, #ff6699, #ff0066);
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
        }
        
        #xpFill { 
            background: linear-gradient(90deg, #00ffff, #00bbbb, #00ffff);
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
        }
        
        #shieldFill { 
            background: linear-gradient(90deg, #00ff88, #00cc66, #00ff88);
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* Boss UI */
        #bossName {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000, 0 0 90px #ff0000;
            display: none;
            z-index: 10;
            animation: bossNamePulse 1s ease-in-out infinite;
        }
        
        @keyframes bossNamePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        
        #bossHealthBar {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            height: 40px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(60, 0, 0, 0.95));
            backdrop-filter: blur(10px);
            border: 6px solid #ff0000;
            border-radius: 25px;
            overflow: hidden;
            display: none;
            z-index: 10;
            box-shadow: 0 0 40px rgba(255,0,0,0.8);
        }
        
        #bossHealthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666, #ff0000);
            background-size: 200% 100%;
            animation: shimmer 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0.98), rgba(30,0,60,0.98));
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
            padding: 20px;
            overflow-y: auto;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        
        #levelUpScreen { display: none; }
        #pauseMenu { display: none; }
        #shopMenu { display: none; }
        #gameOver { 
            display: none; 
            background: radial-gradient(circle, rgba(100,0,0,0.95), rgba(50,0,0,0.95), rgba(0,0,0,0.98));
        }
        
        h1, h2 {
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: clamp(32px, 8vw, 56px);
            text-shadow: 0 0 40px #ffd700, 0 0 80px #ffd700;
            margin-bottom: 30px;
            animation: titleGlow 2s ease-in-out infinite alternate;
            text-align: center;
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px #ffd700); }
            to { filter: drop-shadow(0 0 40px #ffd700); }
        }
        
        /* Hotbar for Abilities */
        #abilityHotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            pointer-events: none;
        }
        
        .ability-slot {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(20,0,40,0.9), rgba(40,0,80,0.9));
            backdrop-filter: blur(10px);
            border: 3px solid #ffd700;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        
        .ability-slot.active {
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0,255,255,0.8);
        }
        
        .ability-slot.on-cooldown {
            border-color: #ff3333;
        }
        
        .ability-icon {
            font-size: 18px;
            margin-bottom: 3px;
        }
        
        .ability-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }
        
        /* Settings Menu */
        #settingsMenu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20,0,40,0.95), rgba(40,0,80,0.95));
            backdrop-filter: blur(20px);
            border: 6px solid #ffd700;
            border-radius: 25px;
            padding: 30px;
            z-index: 2000;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .settings-item {
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        
        .settings-label {
            font-size: 18px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-bottom: 8px;
            width: 100%;
        }
        
        .slider-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-value {
            width: 50px;
            text-align: center;
            font-size: 16px;
            color: #00ffff;
        }
        
        .settings-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 10px;
            background: linear-gradient(90deg, #000, #330066, #6600cc);
            border-radius: 10px;
            outline: none;
        }
        
        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            cursor: pointer;
            box-shadow: 0 0 15px #ffd700;
        }
        
        .upgrade-option, .shop-item, .curse-option {
            background: linear-gradient(135deg, rgba(20,0,40,0.95), rgba(40,0,80,0.95));
            backdrop-filter: blur(10px);
            border: 6px solid;
            border-image: linear-gradient(45deg, #ffd700, #ff00ff, #ffd700) 1;
            padding: 20px;
            margin: 12px 0;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            max-width: 450px;
            position: relative;
            overflow: hidden;
        }
        
        .curse-option {
            border-image: linear-gradient(45deg, #ff3333, #ff9933, #ff3333) 1;
            background: linear-gradient(135deg, rgba(60,0,0,0.95), rgba(80,0,0,0.95));
        }
        
        .upgrade-option:hover::before, .shop-item:hover::before, .curse-option:hover::before {
            left: 100%;
        }
        
        .upgrade-option:hover, .shop-item:hover {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 20px 50px rgba(255,215,0,0.5);
        }
        
        .curse-option:hover {
            background: linear-gradient(135deg, #ff3333, #ff9933);
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 20px 50px rgba(255,51,51,0.5);
        }
        
        .upgrade-title, .shop-title, .curse-title { 
            font-size: 22px; 
            font-weight: bold; 
            margin-bottom: 8px; 
        }
        
        .curse-title { color: #ff9933; }
        .upgrade-desc, .shop-desc, .curse-desc { font-size: 16px; }
        .curse-warning {
            font-size: 14px;
            color: #ff9933;
            margin-top: 8px;
            font-style: italic;
        }
        
        .shop-cost { font-size: 18px; color: #ffd700; font-weight: bold; margin-top: 8px; }
        .shop-owned { font-size: 14px; color: #00ff00; margin-top: 5px; }
        
        button {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            border: 5px solid #fff;
            padding: 15px 30px;
            font-size: clamp(18px, 4vw, 24px);
            font-weight: bold;
            border-radius: 20px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(255,215,0,0.5);
            position: relative;
            overflow: hidden;
            width: 90%;
            max-width: 300px;
            touch-action: manipulation;
            pointer-events: auto !important;
        }
        
        button:hover { 
            transform: scale(1.1); 
            box-shadow: 0 20px 50px rgba(255,215,0,0.8);
        }
        
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(32px, 8vw, 48px);
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 40px #ffd700, 0 0 80px #ffd700;
            opacity: 0;
            z-index: 50;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            text-align: center;
            padding: 0 20px;
        }
        
        .controls { 
            margin-top: 20px; 
            text-align: center; 
            font-size: 16px; 
            line-height: 1.5; 
            width: 100%;
            max-width: 500px;
        }
        
        .controls p {
            margin: 6px 0;
            padding: 6px 12px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            display: inline-block;
            font-size: 14px;
        }
        
        #totalKills {
            position: relative;
            font-size: 18px;
            color: #ffd700;
            text-shadow: 0 0 15px #ffd700;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            margin-bottom: 15px;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            text-align: center;
            width: 90%;
            max-width: 300px;
        }
        
        .tab-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 12px 25px;
            font-size: 18px;
            background: rgba(40,0,80,0.8);
            backdrop-filter: blur(10px);
            border: 3px solid #ffd700;
            transition: all 0.3s;
            flex: 1;
            min-width: 140px;
            max-width: 200px;
            pointer-events: auto;
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            box-shadow: 0 0 30px rgba(255,215,0,0.8);
        }
        
        .skin-preview-container {
            width: 80px;
            height: 80px;
            margin: 12px auto;
            border: 4px solid #ffd700;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.7);
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }
        
        /* Curse Result Notification */
        .curse-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            padding: 30px;
            border-radius: 25px;
            z-index: 200;
            animation: curseResultFade 2s ease-out forwards;
            pointer-events: none;
            text-align: center;
            width: 90%;
            max-width: 500px;
        }
        
        @keyframes curseResultFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }
        
        .curse-buff {
            background: linear-gradient(135deg, rgba(0,100,0,0.9), rgba(0,150,0,0.9));
            border: 6px solid #00ff00;
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
        }
        
        .curse-debuff {
            background: linear-gradient(135deg, rgba(100,0,0,0.9), rgba(150,0,0,0.9));
            border: 6px solid #ff3333;
            color: #ff3333;
            text-shadow: 0 0 30px #ff3333;
        }
        
        /* ==================== MOBILE CONTROLS ==================== */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 180px;
            z-index: 20;
            pointer-events: none;
            display: none;
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            #abilityHotbar {
                bottom: 190px;
            }
            
            #healthBar {
                bottom: 240px;
                height: 30px;
            }
            
            #xpBar {
                bottom: 200px;
                height: 20px;
            }
            
            #shieldBar {
                bottom: 165px;
                height: 20px;
            }
            
            .stat {
                padding: 8px 15px;
                font-size: 14px;
                min-width: 120px;
            }
            
            #bossName {
                font-size: 20px;
                top: 60px;
            }
            
            #bossHealthBar {
                top: 90px;
                height: 35px;
            }
        }
        
        .mobile-joystick {
            position: absolute;
            left: 30px;
            bottom: 30px;
            width: 140px;
            height: 140px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 4px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            pointer-events: auto;
            touch-action: none;
        }
        
        .mobile-joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            touch-action: none;
        }
        
        .mobile-actions {
            position: absolute;
            right: 30px;
            bottom: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            pointer-events: auto;
        }
        
        .mobile-action-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(20,0,40,0.9), rgba(40,0,80,0.9));
            backdrop-filter: blur(10px);
            border: 4px solid #ff00ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #ff00ff;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 25px rgba(255,0,255,0.5);
            transition: all 0.1s;
            touch-action: manipulation;
        }
        
        .mobile-action-btn:active {
            transform: scale(0.9);
            background: linear-gradient(135deg, #ff00ff, #ff66ff);
            color: #000;
        }
        
        .mobile-ability-btns {
            position: absolute;
            right: 30px;
            bottom: 150px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .mobile-ability-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(20,0,40,0.9), rgba(40,0,80,0.9));
            backdrop-filter: blur(10px);
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
            touch-action: manipulation;
        }
        
        .mobile-ability-btn:active {
            background: linear-gradient(135deg, #00ffff, #00bbbb);
            transform: scale(0.95);
        }
        
        /* Mobile Menu Buttons */
        .mobile-menu-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, rgba(20,0,40,0.9), rgba(40,0,80,0.9));
            backdrop-filter: blur(10px);
            border: 3px solid #00ccff;
            border-radius: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #00ccff;
            cursor: pointer;
            z-index: 999;
            touch-action: manipulation;
        }
        
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: flex;
            }
        }
        
        /* Touch instructions */
        #touchInstructions {
            position: absolute;
            bottom: 220px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 14px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            background: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 10px;
            margin: 0 20px;
            display: none;
            z-index: 10;
        }
        
        @media (max-width: 768px) {
            #touchInstructions {
                display: block;
            }
        }
        
        /* Prevent text selection on mobile */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Prevent zoom on double-tap */
        *:focus {
            outline: none;
        }
        
        /* FIX: Make sure menu buttons are clickable */
        button, .upgrade-option, .shop-item, .curse-option, .tab-button {
            pointer-events: auto !important;
            cursor: pointer;
        }
        
        /* FIX: Ensure menu screens are above everything */
        .menu-screen {
            z-index: 1000 !important;
        }
        
        /* FIX: Make sure game UI doesn't block menu buttons */
        #ui, #abilityHotbar, #healthBar, #xpBar, #shieldBar {
            z-index: 10;
        }
        
        /* FIX: Mobile controls should be below menus */
        #mobileControls {
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <canvas id="motionBlurCanvas"></canvas>
        
        <div id="fpsCounter">FPS: 60</div>
        
        <!-- Mobile Menu Button -->
        <div class="mobile-menu-btn" id="mobileMenuBtn">‚â°</div>
        
        <!-- Touch Instructions -->
        <div id="touchInstructions">Touch joystick to move ‚Ä¢ Tap buttons to attack/use abilities</div>
        
        <div id="ui">
            <div class="stat-group">
                <div class="stat"><span class="stat-label">Wave:</span><span id="wave">1</span></div>
                <div class="stat"><span class="stat-label">Kills:</span><span id="kills">0</span></div>
            </div>
            <div class="stat-group">
                <div class="stat"><span class="stat-label">Level:</span><span id="level">1</span></div>
                <div class="stat"><span class="stat-label">Time:</span><span id="time">0:00</span></div>
            </div>
        </div>
        
        <div id="abilityHotbar"></div>
        <div id="bossName"></div>
        <div id="bossHealthBar"><div id="bossHealthFill" style="width:100%;"></div></div>
        <div id="xpBar"><div id="xpFill" style="width:0%;"></div></div>
        <div id="healthBar"><div id="healthFill" style="width:100%;">100 / 100</div></div>
        <div id="shieldBar" style="display:none;"><div id="shieldFill" style="width:100%;">Shield</div></div>
        <div id="notification"></div>
        <div id="curseResult" class="curse-result" style="display:none;"></div>

        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2 style="margin-bottom: 30px; color: #ffd700;">‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>
            <div class="settings-item">
                <div class="settings-label">Audio Volume</div>
                <div class="slider-container">
                    <input type="range" min="0" max="100" value="30" class="settings-slider" id="audioSlider">
                    <div class="slider-value" id="audioValue">30%</div>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-label">Motion Blur</div>
                <div class="slider-container">
                    <input type="range" min="0" max="100" value="70" class="settings-slider" id="blurSlider">
                    <div class="slider-value" id="blurValue">70%</div>
                </div>
            </div>
            <div class="settings-item">
                <div class="settings-label">Visual Effects</div>
                <div class="slider-container">
                    <input type="range" min="0" max="100" value="100" class="settings-slider" id="effectsSlider">
                    <div class="slider-value" id="effectsValue">100%</div>
                </div>
            </div>
            <div style="display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center;">
                <button id="applySettings" style="padding: 12px 30px; font-size: 18px;">‚úÖ APPLY</button>
                <button id="closeSettings" style="padding: 12px 30px; font-size: 18px; background: linear-gradient(135deg, #ff3366, #ff6699);">‚ùå CLOSE</button>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="mobile-joystick" id="joystick">
                <div class="mobile-joystick-handle" id="joystickHandle"></div>
            </div>
            
            <div class="mobile-ability-btns" id="mobileAbilityBtns"></div>
            
            <div class="mobile-actions">
                <div class="mobile-action-btn" id="mobileShootBtn">‚öîÔ∏è</div>
                <div class="mobile-action-btn" id="mobileAbilityBtn">üî•</div>
            </div>
        </div>

        <div id="startScreen" class="menu-screen">
            <h1>‚öîÔ∏è KNIGHT SURVIVOR ‚öîÔ∏è</h1>
            <p style="font-size:clamp(20px, 5vw, 28px);color:#ffd700;margin-bottom:20px;text-shadow:0 0 20px #ffd700;">AAA OPTIMIZED EDITION</p>
            <div id="totalKills">üí∞ Total Kills: <span id="totalKillsCount">0</span></div>
            <button id="startBtn">‚ö° START GAME ‚ö°</button>
            <button id="shopBtn" style="background:linear-gradient(135deg,#ff00ff,#ff66ff);">üõí SHOP</button>
            <button id="settingsBtn" style="background:linear-gradient(135deg,#00ccff,#0099ff);">‚öôÔ∏è SETTINGS</button>
            <div class="controls">
                <p><strong>WASD</strong> to move ‚Ä¢ <strong>P</strong> to pause</p>
                <p><strong>1-5</strong> Activate Abilities ‚Ä¢ Collect XP ‚Ä¢ Dominate!</p>
                <p style="color:#ff0066;">‚ö° OPTIMIZED FOR SMOOTH 60 FPS ‚ö°</p>
                <p style="color:#00ff00;">üì± MOBILE CONTROLS ENABLED</p>
            </div>
        </div>

        <div id="pauseMenu" class="menu-screen">
            <h2>‚è∏Ô∏è PAUSED</h2>
            <button id="resumeBtn">‚ñ∂Ô∏è RESUME</button>
            <button id="shopFromPauseBtn" style="background:linear-gradient(135deg,#ff00ff,#ff66ff);">üõí SHOP</button>
            <button id="settingsFromPauseBtn" style="background:linear-gradient(135deg,#00ccff,#0099ff);">‚öôÔ∏è SETTINGS</button>
            <button id="mainMenuBtn">üè† MAIN MENU</button>
        </div>

        <div id="shopMenu" class="menu-screen">
            <h2>üõí SHOP</h2>
            <div id="shopTotalKills" style="font-size:clamp(24px, 6vw, 32px);color:#ffd700;margin-bottom:20px;text-shadow:0 0 30px #ffd700;">
                üí∞ Kills: <span id="shopKillsCount">0</span>
            </div>
            <div class="tab-buttons">
                <button class="tab-button active" id="upgradesTab">‚ö° UPGRADES</button>
                <button class="tab-button" id="skinsTab">üëï SKINS</button>
            </div>
            <div id="shopContent" style="max-height:400px;overflow-y:auto;width:100%;"></div>
            <button id="closeShopBtn">‚ùå CLOSE</button>
        </div>

        <div id="levelUpScreen" class="menu-screen">
            <h2>‚ú® LEVEL UP! ‚ú®</h2>
            <div id="upgradeOptions"></div>
            <h2 style="margin-top:30px;color:#ff9933;">üòà CURSE UPGRADES üòà</h2>
            <div id="curseOptions" style="display:flex;gap:15px;flex-wrap:wrap;justify-content:center;"></div>
        </div>

        <div id="gameOver" class="menu-screen">
            <h2 style="color:#ff0000;">üíÄ GAME OVER üíÄ</h2>
            <div class="stat">Wave: <span id="finalWave"></span></div>
            <div class="stat">Kills: <span id="finalKills"></span></div>
            <div class="stat">Level: <span id="finalLevel"></span></div>
            <button id="restartBtn">üîÑ PLAY AGAIN üîÑ</button>
            <button id="menuBtn">üè† MAIN MENU</button>
        </div>
    </div>
    <script>
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blurCanvas = document.getElementById('motionBlurCanvas');
        const blurCtx = blurCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Set canvas size based on container
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            blurCanvas.width = width;
            blurCanvas.height = height;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call

        // ==================== SETTINGS SYSTEM ====================
        
        let gameSettings = {
            audioVolume: 0.3,
            motionBlur: 0.7,
            visualEffects: 1.0
        };

        function loadSettings() {
            try {
                const saved = localStorage.getItem('knightSurvivorSettings');
                if (saved) {
                    gameSettings = JSON.parse(saved);
                    document.getElementById('audioSlider').value = gameSettings.audioVolume * 100;
                    document.getElementById('blurSlider').value = gameSettings.motionBlur * 100;
                    document.getElementById('effectsSlider').value = gameSettings.visualEffects * 100;
                    updateSettingsDisplay();
                }
            } catch (e) {
                console.error('Load settings error:', e);
            }
        }

        function saveSettings() {
            try {
                localStorage.setItem('knightSurvivorSettings', JSON.stringify(gameSettings));
            } catch (e) {
                console.error('Save settings error:', e);
            }
        }

        function updateSettingsDisplay() {
            document.getElementById('audioValue').textContent = Math.round(gameSettings.audioVolume * 100) + '%';
            document.getElementById('blurValue').textContent = Math.round(gameSettings.motionBlur * 100) + '%';
            document.getElementById('effectsValue').textContent = Math.round(gameSettings.visualEffects * 100) + '%';
            
            // Apply settings
            if (masterGain) masterGain.gain.value = gameSettings.audioVolume;
            blurCanvas.style.opacity = gameSettings.motionBlur;
        }

        // ==================== PERFORMANCE OPTIMIZATION ====================
        
        // FPS Counter
        let fps = 60;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                document.getElementById('fpsCounter').style.color = fps >= 55 ? '#0f0' : fps >= 30 ? '#ff0' : '#f00';
            }
        }

        // Object Pooling System
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 100) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(createFn());
                }
            }
            
            get(...args) {
                let obj = this.pool.pop();
                if (!obj) obj = this.createFn();
                this.resetFn(obj, ...args);
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.pool.push(obj);
                }
            }
            
            releaseAll() {
                this.pool.push(...this.active);
                this.active = [];
            }
        }

        // Particle Pool (10x faster than creating new particles!)
        const particlePool = new ObjectPool(
            () => ({ x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0, decay: 0 }),
            (p, x, y, color, vx, vy, size, life) => {
                p.x = x;
                p.y = y;
                p.color = color;
                p.vx = vx !== undefined ? vx : (Math.random() - 0.5) * 6;
                p.vy = vy !== undefined ? vy : (Math.random() - 0.5) * 6;
                p.size = size || Math.random() * 5 + 2;
                p.life = life || 1;
                p.decay = 0.02;
            },
            500
        );

        // ==================== SAVE SYSTEM ====================
        
        let persistentData = {
            totalKills: 0,
            ownedSkins: ['classic'],
            selectedSkin: 'classic',
            permanentUpgrades: {
                startingSpeed: 0,
                startingHealth: 0,
                startingDamage: 0,
                startingRegen: 0
            }
        };

        function loadPersistentData() {
            try {
                const saved = localStorage.getItem('knightSurvivorAAA');
                if (saved) persistentData = JSON.parse(saved);
            } catch (e) {
                console.error('Load error:', e);
            }
            updateTotalKillsDisplay();
        }

        function savePersistentData() {
            try {
                localStorage.setItem('knightSurvivorAAA', JSON.stringify(persistentData));
                updateTotalKillsDisplay();
            } catch (e) {
                console.error('Save error:', e);
            }
        }

        function updateTotalKillsDisplay() {
            document.getElementById('totalKillsCount').textContent = persistentData.totalKills;
            document.getElementById('shopKillsCount').textContent = persistentData.totalKills;
        }

        // ==================== SKIN SYSTEM ====================
        
        const SKINS = {
            classic: {
                name: '‚öîÔ∏è Classic Knight',
                cost: 0,
                armor: '#5a9adf',
                metal: '#99ccff',
                cape: '#dd0000',
                accent: '#ffd700',
                shield: '#e0e0e0'
            },
            golden: {
                name: 'üëë Golden King',
                cost: 100,
                armor: '#ffd700',
                metal: '#ffed4e',
                cape: '#aa66ff',
                accent: '#ff6600',
                shield: '#ffffff'
            },
            shadow: {
                name: 'üåë Shadow Assassin',
                cost: 250,
                armor: '#333333',
                metal: '#555555',
                cape: '#1a1a1a',
                accent: '#9900ff',
                shield: '#666666',
                eyes: '#ff0000'
            },
            ice: {
                name: '‚ùÑÔ∏è Frozen Paladin',
                cost: 500,
                armor: '#66ddff',
                metal: '#99ffff',
                cape: '#00ffff',
                accent: '#ffffff',
                shield: '#ccffff'
            },
            fire: {
                name: 'üî• Flame Lord',
                cost: 750,
                armor: '#ff4400',
                metal: '#ff6600',
                cape: '#ff0000',
                accent: '#ffaa00',
                shield: '#ff8800',
                glow: '#ff6600'
            },
            void: {
                name: 'üåå Void Knight',
                cost: 1000,
                armor: '#6600cc',
                metal: '#9900ff',
                cape: '#4400aa',
                accent: '#ff00ff',
                shield: '#aa66ff',
                glow: '#ff00ff'
            }
        };

        // ==================== AUDIO ====================
        
        let audioCtx, masterGain;
        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.connect(audioCtx.destination);
                masterGain.gain.value = gameSettings.audioVolume;
            } catch (e) {
                console.warn('Audio not supported:', e);
            }
        }

        function playSound(type, pitch = 1, volume = 1) {
            if (!audioCtx || audioCtx.state === 'suspended') {
                try {
                    if (audioCtx) audioCtx.resume();
                } catch (e) {
                    return;
                }
            }
            
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(masterGain);

                switch(type) {
                    case 'shoot':
                        osc.frequency.value = 900 * pitch;
                        osc.type = 'square';
                        gain.gain.setValueAtTime(0.08 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.08);
                        break;
                    case 'hit':
                        osc.frequency.value = 350 * pitch;
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(0.12 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                        break;
                    case 'death':
                        osc.frequency.value = 180 * pitch;
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(0.2 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.4);
                        break;
                    case 'levelup':
                        [350, 450, 650, 850, 1100].forEach((freq, i) => {
                            setTimeout(() => {
                                const o = audioCtx.createOscillator();
                                const g = audioCtx.createGain();
                                o.connect(g);
                                g.connect(masterGain);
                                o.frequency.value = freq * pitch;
                                o.type = 'sine';
                                g.gain.setValueAtTime(0.15 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
                                o.start();
                                o.stop(audioCtx.currentTime + 0.25);
                            }, i * 70);
                        });
                        break;
                    case 'ability':
                        osc.frequency.value = 700 * pitch;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.25 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.3);
                        break;
                    case 'explosion':
                        osc.frequency.value = 60 * pitch;
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(0.3 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.6);
                        break;
                    case 'curse':
                        osc.frequency.value = 200 * pitch;
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(0.2 * volume * gameSettings.audioVolume, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.5);
                        break;
                }
            } catch (e) {
                // Silent fail for audio errors
            }
        }

        // ==================== GAME STATE ====================
        
        let gameState = 'start';
        let wave = 1;
        let kills = 0;
        let gameTime = 0;
        let player, enemies = [], projectiles = [], xpOrbs = [];
        let keys = {};
        let lastAttackTime = 0;
        let waveEnemiesSpawned = 0;
        let waveEnemiesTotal = 0;
        let timeSinceWaveComplete = 0;
        let camera = { x: 0, y: 0 };
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let currentBoss = null;
        let lastTime = Date.now();
        let accumulatedTime = 0;
        let abilityHotbar = [];

        let playerStats = {
            maxHealth: 100,
            health: 100,
            speed: 8,
            damage: 30,
            attackSpeed: 500,
            projectileSpeed: 12,
            projectileCount: 1,
            range: 500,
            level: 1,
            xp: 0,
            xpNeeded: 15,
            regeneration: 0.15,
            critChance: 0.1,
            critMultiplier: 2.5,
            piercing: 0,
            lifeSteal: 0,
            orbitingSwords: 0,
            fireTornado: false,
            lightningChain: false,
            iceNova: false,
            meteorShower: false,
            voidRift: false,
            size: 40
        };

        let abilityCooldowns = {
            fireTornado: 0,
            lightningChain: 0,
            iceNova: 0,
            meteorShower: 0,
            voidRift: 0
        };

        const ABILITY_MAX_COOLDOWN = {
            fireTornado: 8000,
            lightningChain: 5000,
            iceNova: 10000,
            meteorShower: 20000,
            voidRift: 25000
        };

        const ABILITY_ICONS = {
            fireTornado: 'üî•',
            lightningChain: '‚ö°',
            iceNova: '‚ùÑÔ∏è',
            meteorShower: '‚òÑÔ∏è',
            voidRift: 'üåå'
        };

        // ==================== MOBILE CONTROLS ====================
        
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickRadius = 60;

        function initMobileControls() {
            const joystick = document.getElementById('joystick');
            const handle = document.getElementById('joystickHandle');
            const shootBtn = document.getElementById('mobileShootBtn');
            const abilityBtn = document.getElementById('mobileAbilityBtn');
            
            // Update mobile ability buttons
            updateMobileAbilityButtons();
            
            // Joystick touch start
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                updateJoystick(touch);
            });
            
            // Joystick touch move
            document.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                updateJoystick(e.touches[0]);
            }, { passive: false });
            
            // Joystick touch end
            document.addEventListener('touchend', (e) => {
                if (!joystickActive) return;
                joystickActive = false;
                resetJoystick();
            });
            
            // Shoot button
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState === 'playing') {
                    keys[' '] = true;
                }
            });
            
            shootBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
            
            // Ability button
            abilityBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState === 'playing') {
                    // Auto-attack when ability button is pressed
                    keys[' '] = true;
                }
            });
            
            abilityBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });
            
            // Mobile menu button
            document.getElementById('mobileMenuBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    gameState = 'paused';
                    document.getElementById('pauseMenu').style.display = 'flex';
                }
            });
            
            // Also add mouse events for testing on desktop
            joystick.addEventListener('mousedown', (e) => {
                joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                updateJoystick(e);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!joystickActive) return;
                updateJoystick(e);
            });
            
            document.addEventListener('mouseup', () => {
                if (!joystickActive) return;
                joystickActive = false;
                resetJoystick();
            });
        }

        function updateMobileAbilityButtons() {
            const container = document.getElementById('mobileAbilityBtns');
            container.innerHTML = '';
            
            abilityHotbar.forEach((ability, index) => {
                const btn = document.createElement('div');
                btn.className = 'mobile-ability-btn';
                btn.innerHTML = ability.icon;
                btn.title = ability.name;
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameState === 'playing' && ability.cooldown <= 0) {
                        if (ability.id === 'fireTornado') {
                            abilityCooldowns.fireTornado = 1;
                        } else if (ability.id === 'lightningChain') {
                            abilityCooldowns.lightningChain = 1;
                        } else if (ability.id === 'iceNova') {
                            abilityCooldowns.iceNova = 1;
                        } else if (ability.id === 'meteorShower') {
                            abilityCooldowns.meteorShower = 1;
                        } else if (ability.id === 'voidRift') {
                            abilityCooldowns.voidRift = 1;
                        }
                        playSound('ability', 1, 1);
                    }
                });
                
                // Add mouse events for desktop testing
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (gameState === 'playing' && ability.cooldown <= 0) {
                        if (ability.id === 'fireTornado') {
                            abilityCooldowns.fireTornado = 1;
                        } else if (ability.id === 'lightningChain') {
                            abilityCooldowns.lightningChain = 1;
                        } else if (ability.id === 'iceNova') {
                            abilityCooldowns.iceNova = 1;
                        } else if (ability.id === 'meteorShower') {
                            abilityCooldowns.meteorShower = 1;
                        } else if (ability.id === 'voidRift') {
                            abilityCooldowns.voidRift = 1;
                        }
                        playSound('ability', 1, 1);
                    }
                });
                
                container.appendChild(btn);
            });
        }

        function updateJoystick(touch) {
            const handle = document.getElementById('joystickHandle');
            const rect = handle.parentElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const touchX = touch.clientX || touch.pageX;
            const touchY = touch.clientY || touch.pageY;
            
            let deltaX = touchX - centerX;
            let deltaY = touchY - centerY;
            
            // Limit to joystick radius
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (distance > joystickRadius) {
                deltaX = (deltaX / distance) * joystickRadius;
                deltaY = (deltaY / distance) * joystickRadius;
            }
            
            // Update handle position
            handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            // Update movement keys based on joystick position
            const deadzone = 10;
            
            // Reset keys
            keys['w'] = false;
            keys['s'] = false;
            keys['a'] = false;
            keys['d'] = false;
            
            // Set keys based on joystick direction
            if (deltaY < -deadzone) {
                keys['w'] = true;
            } else if (deltaY > deadzone) {
                keys['s'] = true;
            }
            
            if (deltaX < -deadzone) {
                keys['a'] = true;
            } else if (deltaX > deadzone) {
                keys['d'] = true;
            }
        }

        function resetJoystick() {
            const handle = document.getElementById('joystickHandle');
            handle.style.transform = 'translate(-50%, -50%)';
            
            // Reset all movement keys
            keys['w'] = false;
            keys['s'] = false;
            keys['a'] = false;
            keys['d'] = false;
        }

        // ==================== MOTION BLUR ====================
        
        function applyMotionBlur() {
            blurCtx.globalAlpha = gameSettings.motionBlur * 0.15;
            blurCtx.drawImage(canvas, 0, 0);
            blurCtx.globalAlpha = 1;
        }

        // ==================== SCREEN EFFECTS ====================
        
        function addScreenShake(intensity) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity * gameSettings.visualEffects);
        }

        function updateScreenShake() {
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= 0.85;
                if (screenShake.intensity < 0.1) {
                    screenShake.intensity = 0;
                    screenShake.x = 0;
                    screenShake.y = 0;
                }
            }
        }

        // ==================== HOTBAR SYSTEM ====================
        
        function updateHotbar() {
            const hotbar = document.getElementById('abilityHotbar');
            hotbar.innerHTML = '';
            
            abilityHotbar = [];
            
            if (playerStats.fireTornado) {
                abilityHotbar.push({
                    id: 'fireTornado',
                    name: 'Fire Tornado',
                    icon: 'üî•',
                    cooldown: abilityCooldowns.fireTornado,
                    maxCooldown: ABILITY_MAX_COOLDOWN.fireTornado,
                    key: '1'
                });
            }
            if (playerStats.lightningChain) {
                abilityHotbar.push({
                    id: 'lightningChain',
                    name: 'Lightning Chain',
                    icon: '‚ö°',
                    cooldown: abilityCooldowns.lightningChain,
                    maxCooldown: ABILITY_MAX_COOLDOWN.lightningChain,
                    key: '2'
                });
            }
            if (playerStats.iceNova) {
                abilityHotbar.push({
                    id: 'iceNova',
                    name: 'Ice Nova',
                    icon: '‚ùÑÔ∏è',
                    cooldown: abilityCooldowns.iceNova,
                    maxCooldown: ABILITY_MAX_COOLDOWN.iceNova,
                    key: '3'
                });
            }
            if (playerStats.meteorShower) {
                abilityHotbar.push({
                    id: 'meteorShower',
                    name: 'Meteor Shower',
                    icon: '‚òÑÔ∏è',
                    cooldown: abilityCooldowns.meteorShower,
                    maxCooldown: ABILITY_MAX_COOLDOWN.meteorShower,
                    key: '4'
                });
            }
            if (playerStats.voidRift) {
                abilityHotbar.push({
                    id: 'voidRift',
                    name: 'Void Rift',
                    icon: 'üåå',
                    cooldown: abilityCooldowns.voidRift,
                    maxCooldown: ABILITY_MAX_COOLDOWN.voidRift,
                    key: '5'
                });
            }
            
            abilityHotbar.forEach((ability, index) => {
                const slot = document.createElement('div');
                slot.className = 'ability-slot';
                if (ability.cooldown <= 0) {
                    slot.classList.add('active');
                } else {
                    slot.classList.add('on-cooldown');
                }
                
                const cooldownPercent = Math.min(100, (ability.cooldown / ability.maxCooldown) * 100);
                const cooldownSeconds = Math.ceil(ability.cooldown / 1000);
                
                slot.innerHTML = `
                    <div class="ability-icon">${ability.icon}</div>
                    ${ability.cooldown > 0 ? 
                        `<div class="ability-cooldown">${cooldownSeconds}</div>` : 
                        ''}
                `;
                
                hotbar.appendChild(slot);
            });
            
            // Update mobile ability buttons
            updateMobileAbilityButtons();
        }

        // ==================== BACKGROUND RENDERING ====================
        
        function drawBackground() {
            // Clear canvas
            ctx.fillStyle = '#0a0a2a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground tiles
            const tileSize = 50;
            const startX = Math.floor(camera.x / tileSize) * tileSize;
            const startY = Math.floor(camera.y / tileSize) * tileSize;
            const endX = startX + canvas.width + tileSize * 2;
            const endY = startY + canvas.height + tileSize * 2;

            for (let x = startX; x < endX; x += tileSize) {
                for (let y = startY; y < endY; y += tileSize) {
                    const screenX = x - camera.x;
                    const screenY = y - camera.y;
                    
                    if ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) {
                        ctx.fillStyle = '#1a3a1a';
                    } else {
                        ctx.fillStyle = '#0a2a0a';
                    }
                    
                    ctx.fillRect(screenX, screenY, tileSize, tileSize);
                    
                    ctx.strokeStyle = 'rgba(100, 255, 100, 0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX, screenY, tileSize, tileSize);
                }
            }
        }

        // ==================== PLAYER CLASS ====================
        
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.size = playerStats.size;
                this.angle = 0;
                this.walkAnimation = 0;
                this.isMoving = false;
                this.skin = SKINS[persistentData.selectedSkin] || SKINS.classic;
                this.hitTimer = 0;
                this.auraRotation = 0;
                this.trail = [];
                this.maxTrail = 10;
            }

            drawDetailedKnight() {
                const s = this.size;
                const c = this.skin;
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.ellipse(0, s*0.95, s*0.9, s*0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Body/Armor
                ctx.fillStyle = c.armor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = c.armor;
                ctx.fillRect(-s*0.4, -s*0.2, s*0.8, s*0.8);
                ctx.shadowBlur = 0;
                
                // Chest plate
                ctx.fillStyle = c.metal;
                ctx.fillRect(-s*0.35, -s*0.15, s*0.7, s*0.4);
                
                // Belt
                ctx.fillStyle = c.accent;
                ctx.shadowBlur = 15;
                ctx.shadowColor = c.accent;
                ctx.fillRect(-s*0.4, s*0.3, s*0.8, s*0.1);
                ctx.shadowBlur = 0;
                
                // Legs
                ctx.fillStyle = c.armor;
                ctx.fillRect(-s*0.35, s*0.4, s*0.25, s*0.4);
                ctx.fillRect(s*0.1, s*0.4, s*0.25, s*0.4);
                
                // Cape
                ctx.fillStyle = c.cape;
                ctx.shadowBlur = 15;
                ctx.shadowColor = c.cape;
                ctx.beginPath();
                ctx.moveTo(-s*0.45, -s*0.15);
                ctx.quadraticCurveTo(-s*0.7, s*0.3, -s*0.4, s*0.6);
                ctx.lineTo(-s*0.35, s*0.5);
                ctx.quadraticCurveTo(-s*0.45, s*0.15, -s*0.45, -s*0.15);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Helmet
                ctx.fillStyle = c.armor;
                ctx.shadowBlur = 10;
                ctx.shadowColor = c.armor;
                ctx.fillRect(-s*0.3, -s*0.6, s*0.6, s*0.5);
                ctx.fillRect(-s*0.4, -s*0.55, s*0.8, s*0.15);
                ctx.shadowBlur = 0;
                
                // Visor
                ctx.fillStyle = '#000000';
                ctx.fillRect(-s*0.25, -s*0.4, s*0.5, s*0.15);
                
                // Shield
                ctx.save();
                ctx.translate(-s*0.6, 0);
                ctx.fillStyle = c.shield;
                ctx.shadowBlur = 20;
                ctx.shadowColor = c.accent;
                ctx.beginPath();
                ctx.arc(0, 0, s*0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                
                // Sword
                ctx.save();
                ctx.translate(s*0.6, -s*0.1);
                ctx.fillStyle = c.metal;
                ctx.shadowBlur = 25;
                ctx.shadowColor = c.accent;
                ctx.fillRect(-s*0.05, -s*0.4, s*0.1, s*0.6);
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            draw() {
                ctx.save();
                const screenX = this.x + screenShake.x;
                const screenY = this.y + screenShake.y;
                ctx.translate(screenX, screenY);
                
                let bounce = 0;
                if (this.isMoving) {
                    this.walkAnimation += 0.3;
                    bounce = Math.sin(this.walkAnimation) * 3;
                }
                ctx.translate(0, bounce);
                ctx.rotate(this.angle);
                
                // Hit effect
                if (this.hitTimer > 0) {
                    ctx.globalAlpha = (this.hitTimer / 10) * gameSettings.visualEffects;
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowBlur = 40 * gameSettings.visualEffects;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillRect(-this.size*1.2, -this.size*1.2, this.size*2.4, this.size*2.4);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    this.hitTimer--;
                }
                
                this.drawDetailedKnight();
                ctx.restore();
            }

            update(deltaTime) {
                const prevHealth = playerStats.health;
                this.isMoving = false;
                
                let dx = 0, dy = 0;
                if (keys['w'] || keys['arrowup']) { dy -= 1; this.isMoving = true; }
                if (keys['s'] || keys['arrowdown']) { dy += 1; this.isMoving = true; }
                if (keys['a'] || keys['arrowleft']) { dx -= 1; this.isMoving = true; }
                if (keys['d'] || keys['arrowright']) { dx += 1; this.isMoving = true; }

                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }

                // Keep player within bounds
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x + dx * playerStats.speed));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y + dy * playerStats.speed));

                if (dx !== 0 || dy !== 0) {
                    this.angle = Math.atan2(dy, dx);
                }

                if (playerStats.health < playerStats.maxHealth) {
                    playerStats.health = Math.min(playerStats.maxHealth, playerStats.health + playerStats.regeneration * deltaTime / 16);
                    updateHealthBar();
                }

                if (playerStats.health < prevHealth) {
                    this.hitTimer = 10;
                }
            }

            takeDamage(damage) {
                playerStats.health -= damage;
                addScreenShake(10);
                updateHealthBar();
                playSound('hit', 0.8, 0.8);
                this.hitTimer = 10;
                
                for (let i = 0; i < 6; i++) {
                    particlePool.get(
                        this.x, this.y, '#ff0000',
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        Math.random() * 4 + 2, 1
                    );
                }
            }
        }

        // ==================== ENEMY CLASS ====================
        
        class Enemy {
            constructor(wave, x, y) {
                this.size = 30;
                const angle = Math.random() * Math.PI * 2;
                const dist = 400 + Math.random() * 200;
                this.x = x || player.x + Math.cos(angle) * dist;
                this.y = y || player.y + Math.sin(angle) * dist;
                
                this.speed = 2.5 + wave * 0.15;
                this.health = 40 + wave * 8;
                this.maxHealth = this.health;
                this.damage = 8 + wave * 1.2;
                
                const rand = Math.random();
                if (rand > 0.85) {
                    this.type = 'fast';
                    this.speed *= 2.2;
                    this.health *= 0.5;
                    this.size *= 0.75;
                    this.color = '#ff3366';
                } else if (rand > 0.7) {
                    this.type = 'tank';
                    this.speed *= 0.6;
                    this.health *= 2.5;
                    this.size *= 1.4;
                    this.color = '#6633ff';
                } else {
                    this.type = 'normal';
                    this.color = '#ff6600';
                }
                
                this.wobble = Math.random() * Math.PI * 2;
                this.hitTimer = 0;
            }

            draw() {
                const screenX = this.x + screenShake.x;
                const screenY = this.y + screenShake.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                
                // Hit effect
                if (this.hitTimer > 0) {
                    ctx.globalAlpha = (this.hitTimer / 10) * gameSettings.visualEffects;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 30 * gameSettings.visualEffects;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillRect(-this.size*1.2, -this.size*1.2, this.size*2.4, this.size*2.4);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                    this.hitTimer--;
                }
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, this.size*0.8, this.size*0.9, this.size*0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.rotate(Math.sin(this.wobble) * 0.15);
                
                // Enemy body
                const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                bodyGradient.addColorStop(0, this.color);
                bodyGradient.addColorStop(1, '#000000');
                ctx.fillStyle = bodyGradient;
                ctx.shadowBlur = 25 * gameSettings.visualEffects;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Eyes
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 20 * gameSettings.visualEffects;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.arc(-this.size * 0.3, -this.size * 0.2, this.size * 0.2, 0, Math.PI * 2);
                ctx.arc(this.size * 0.3, -this.size * 0.2, this.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.restore();
                
                // Health bar
                const barWidth = this.size * 3;
                const barHeight = 8;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillRect(screenX - barWidth/2, screenY - this.size - 22, barWidth, barHeight);
                
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
                ctx.fillRect(screenX - barWidth/2, screenY - this.size - 22, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX - barWidth/2, screenY - this.size - 22, barWidth, barHeight);
            }

            update(deltaTime) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed * deltaTime / 16;
                    this.y += (dy / dist) * this.speed * deltaTime / 16;
                }
                
                this.wobble += 0.15 * deltaTime / 16;

                if (dist < this.size + player.size) {
                    player.takeDamage(this.damage * 0.05 * deltaTime / 16);
                }
            }
        }

        class MiniBoss extends Enemy {
            constructor(wave) {
                super(wave);
                this.size = 55;
                this.health = 400 + wave * 40;
                this.maxHealth = this.health;
                this.speed = 1.5 + wave * 0.1;
                this.damage = 18 + wave * 2;
                this.color = '#ff00ff';
                this.isBoss = true;
                this.type = 'miniboss';
            }
        }

        class Boss extends Enemy {
            constructor(wave) {
                super(wave);
                this.size = 90;
                this.health = 1200 + wave * 100;
                this.maxHealth = this.health;
                this.speed = 1 + wave * 0.05;
                this.damage = 30 + wave * 3;
                this.color = '#ff0000';
                this.isBoss = true;
                this.type = 'boss';
            }
        }

        // ==================== PROJECTILE CLASS ====================
        
        class Projectile {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                const angle = Math.atan2(targetY - y, targetX - x);
                this.vx = Math.cos(angle) * playerStats.projectileSpeed;
                this.vy = Math.sin(angle) * playerStats.projectileSpeed;
                this.size = 14;
                this.damage = playerStats.damage;
                this.angle = angle;
                this.piercing = playerStats.piercing;
                this.hitEnemies = [];
                this.crit = Math.random() < playerStats.critChance;
                if (this.crit) this.damage *= playerStats.critMultiplier;
            }

            draw() {
                const screenX = this.x + screenShake.x;
                const screenY = this.y + screenShake.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.5, this.crit ? '#ffff00' : '#00ffff');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 25 * gameSettings.visualEffects;
                ctx.shadowColor = this.crit ? '#ffff00' : '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                ctx.shadowBlur = 0;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime / 16;
                this.y += this.vy * deltaTime / 16;
            }
        }

        // ==================== XP ORB (WITH AUTO PICKUP) ====================
        
        class XPOrb {
            constructor(x, y, value = 1) {
                this.x = x;
                this.y = y;
                this.size = 16;
                this.value = value * 2; // DOUBLE XP
                this.pulse = 0;
                this.age = 0;
                this.autoPickup = false;
            }

            draw() {
                this.pulse += 0.15;
                const pulseSize = this.size + Math.sin(this.pulse) * 5;
                const screenX = this.x + screenShake.x;
                const screenY = this.y + screenShake.y;
                
                const color = this.autoPickup ? '#ff9900' : '#00ffff';
                const shadowColor = this.autoPickup ? '#ff9900' : '#00ffff';
                
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, pulseSize);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.5, color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 30 * gameSettings.visualEffects;
                ctx.shadowColor = shadowColor;
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            update(deltaTime) {
                this.age += deltaTime;
                
                if (this.age > 8000 && !this.autoPickup) {
                    this.autoPickup = true;
                }
                
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                const speed = this.autoPickup ? 50 : (dist < 300 ? 15 : 0);
                
                if (speed > 0 && dist > 0) {
                    this.x += (dx / dist) * speed * deltaTime / 16;
                    this.y += (dy / dist) * speed * deltaTime / 16;
                }

                if (dist < player.size + this.size) {
                    playerStats.xp += this.value;
                    updateUI();
                    checkLevelUp();
                    playSound('ability', 1.5, 0.3);
                    return true;
                }
                return false;
            }
        }

        // ==================== ABILITIES ====================
        
        let activeEffects = {
            fireTornado: { active: false, x: 0, y: 0, startTime: 0, particles: [] },
            lightningChain: { active: false, enemies: [], startTime: 0 },
            iceNova: { active: false, x: 0, y: 0, startTime: 0, radius: 0 },
            meteorShower: { active: false, meteors: [], startTime: 0 },
            voidRift: { active: false, x: 0, y: 0, startTime: 0, particles: [] }
        };

        function updateAbilities(deltaTime) {
            // Orbiting Swords
            if (playerStats.orbitingSwords > 0) {
                const swordSpeed = 0.05;
                const swordRadius = 80;
                for (let i = 0; i < playerStats.orbitingSwords; i++) {
                    const angle = (Date.now() * swordSpeed + (Math.PI * 2 / playerStats.orbitingSwords) * i);
                    const x = player.x + Math.cos(angle) * swordRadius;
                    const y = player.y + Math.sin(angle) * swordRadius;
                    
                    const screenX = x + screenShake.x;
                    const screenY = y + screenShake.y;
                    
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(angle + Math.PI / 2);
                    
                    const swordGradient = ctx.createLinearGradient(0, -25, 0, 25);
                    swordGradient.addColorStop(0, '#ffff00');
                    swordGradient.addColorStop(0.5, '#ffd700');
                    swordGradient.addColorStop(1, '#ff9900');
                    
                    ctx.fillStyle = swordGradient;
                    ctx.shadowBlur = 25 * gameSettings.visualEffects;
                    ctx.shadowColor = '#ffd700';
                    ctx.fillRect(-6, -25, 12, 50);
                    ctx.restore();
                    ctx.shadowBlur = 0;
                    
                    enemies.forEach(enemy => {
                        const dx = enemy.x - x;
                        const dy = enemy.y - y;
                        if (Math.sqrt(dx * dx + dy * dy) < enemy.size + 15) {
                            enemy.health -= 0.5 * deltaTime / 16;
                            enemy.hitTimer = 5;
                        }
                    });
                }
            }
            
            // Fire Tornado
            if (playerStats.fireTornado && abilityCooldowns.fireTornado <= 0 && enemies.length > 0) {
                abilityCooldowns.fireTornado = ABILITY_MAX_COOLDOWN.fireTornado;
                playSound('ability', 0.8, 1.2);
                
                activeEffects.fireTornado = {
                    active: true,
                    x: player.x,
                    y: player.y,
                    startTime: Date.now()
                };
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 200) {
                        enemy.health -= 45;
                        enemy.hitTimer = 10;
                    }
                });
            }
            
            // Lightning Chain
            if (playerStats.lightningChain && abilityCooldowns.lightningChain <= 0 && enemies.length >= 3) {
                abilityCooldowns.lightningChain = ABILITY_MAX_COOLDOWN.lightningChain;
                playSound('ability', 1.2, 1);
                
                let targets = enemies.slice().sort((a, b) => {
                    const distA = Math.sqrt((a.x - player.x) ** 2 + (a.y - player.y) ** 2);
                    const distB = Math.sqrt((b.x - player.x) ** 2 + (b.y - player.y) ** 2);
                    return distA - distB;
                }).slice(0, 5);
                
                activeEffects.lightningChain = {
                    active: true,
                    enemies: targets,
                    startTime: Date.now()
                };
                
                targets.forEach((enemy) => {
                    enemy.health -= 25;
                    enemy.hitTimer = 10;
                    addScreenShake(8);
                });
            }
            
            Object.keys(abilityCooldowns).forEach(key => {
                if (abilityCooldowns[key] > 0) {
                    abilityCooldowns[key] -= deltaTime;
                }
            });
            
            updateHotbar();
        }

        // ==================== GAME INITIALIZATION ====================
        
        function initGame() {
            player = new Player();
            enemies = [];
            projectiles = [];
            xpOrbs = [];
            particlePool.releaseAll();
            wave = 1;
            kills = 0;
            gameTime = 0;
            accumulatedTime = 0;
            lastAttackTime = 0;
            waveEnemiesSpawned = 0;
            waveEnemiesTotal = 0;
            timeSinceWaveComplete = 0;
            camera = { x: 0, y: 0 };
            screenShake = { x: 0, y: 0, intensity: 0 };
            currentBoss = null;
            lastTime = Date.now();
            
            activeEffects = {
                fireTornado: { active: false, x: 0, y: 0, startTime: 0, particles: [] },
                lightningChain: { active: false, enemies: [], startTime: 0 },
                iceNova: { active: false, x: 0, y: 0, startTime: 0, radius: 0 },
                meteorShower: { active: false, meteors: [], startTime: 0 },
                voidRift: { active: false, x: 0, y: 0, startTime: 0, particles: [] }
            };
            
            playerStats = {
                maxHealth: 100 + persistentData.permanentUpgrades.startingHealth * 25,
                health: 100 + persistentData.permanentUpgrades.startingHealth * 25,
                speed: 8 + persistentData.permanentUpgrades.startingSpeed * 0.1,
                damage: 30 + persistentData.permanentUpgrades.startingDamage * 10,
                attackSpeed: 500,
                projectileSpeed: 12,
                projectileCount: 1,
                range: 500,
                level: 1,
                xp: 0,
                xpNeeded: 15,
                regeneration: 0.15 + persistentData.permanentUpgrades.startingRegen * 0.1,
                critChance: 0.1,
                critMultiplier: 2.5,
                piercing: 0,
                lifeSteal: 0,
                orbitingSwords: 0,
                fireTornado: false,
                lightningChain: false,
                iceNova: false,
                meteorShower: false,
                voidRift: false,
                size: canvas.width < 768 ? 30 : 40
            };
            
            abilityCooldowns = {
                fireTornado: 0,
                lightningChain: 0,
                iceNova: 0,
                meteorShower: 0,
                voidRift: 0
            };
            
            updateUI();
            updateHealthBar();
            updateHotbar();
            hideBossUI();
            
            blurCtx.clearRect(0, 0, blurCanvas.width, blurCanvas.height);
            
            // Initialize mobile controls on mobile devices
            if ('ontouchstart' in window) {
                initMobileControls();
            }
        }

        function spawnWave() {
            if (wave % 10 === 0) {
                currentBoss = new Boss(wave);
                enemies.push(currentBoss);
                waveEnemiesTotal = 1;
                waveEnemiesSpawned = 1;
                showBossUI('üëë BOSS üëë');
                playSound('explosion', 0.7, 1.5);
                addScreenShake(40);
                showNotification('BOSS BATTLE!', '#ff0000');
            } else if (wave % 5 === 0) {
                currentBoss = new MiniBoss(wave);
                enemies.push(currentBoss);
                waveEnemiesTotal = 1;
                waveEnemiesSpawned = 1;
                showBossUI('‚ö° MINI-BOSS ‚ö°');
                playSound('explosion', 0.9, 1.2);
                addScreenShake(30);
                showNotification('MINI-BOSS!', '#ff00ff');
            } else {
                waveEnemiesTotal = 10 + wave * 2;
                waveEnemiesSpawned = 0;
            }
            timeSinceWaveComplete = 0;
        }

        function spawnEnemy() {
            if (waveEnemiesSpawned < waveEnemiesTotal) {
                enemies.push(new Enemy(wave));
                waveEnemiesSpawned++;
            }
        }

        function shootAtNearestEnemy() {
            if (enemies.length === 0) return;
            
            let targets = enemies.filter(e => {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                return Math.sqrt(dx * dx + dy * dy) < playerStats.range;
            }).sort((a, b) => {
                const distA = Math.sqrt((a.x - player.x) ** 2 + (a.y - player.y) ** 2);
                const distB = Math.sqrt((b.x - player.x) ** 2 + (b.y - player.y) ** 2);
                return distA - distB;
            });
            
            const shootCount = Math.min(playerStats.projectileCount, targets.length);
            for (let i = 0; i < shootCount; i++) {
                projectiles.push(new Projectile(player.x, player.y, targets[i].x, targets[i].y));
                playSound('shoot', 0.9 + i * 0.1, 0.4);
            }
        }

        function updateHealthBar() {
            const healthPercent = Math.max(0, (playerStats.health / playerStats.maxHealth) * 100);
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthFill').textContent = 
                Math.round(Math.max(0, playerStats.health)) + ' / ' + playerStats.maxHealth;
        }

        function updateUI() {
            document.getElementById('wave').textContent = wave;
            document.getElementById('level').textContent = playerStats.level;
            document.getElementById('kills').textContent = kills;
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            document.getElementById('time').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
            
            const xpPercent = Math.min(100, (playerStats.xp / playerStats.xpNeeded) * 100);
            document.getElementById('xpFill').style.width = xpPercent + '%';
            document.getElementById('xpFill').textContent = 
                Math.round(playerStats.xp) + ' / ' + playerStats.xpNeeded;
        }

        function showBossUI(name) {
            document.getElementById('bossName').textContent = name;
            document.getElementById('bossName').style.display = 'block';
            document.getElementById('bossHealthBar').style.display = 'block';
        }

        function hideBossUI() {
            document.getElementById('bossName').style.display = 'none';
            document.getElementById('bossHealthBar').style.display = 'none';
        }

        function updateBossHealth() {
            if (currentBoss && currentBoss.isBoss) {
                const percent = (currentBoss.health / currentBoss.maxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = percent + '%';
                document.getElementById('bossHealthFill').textContent = 
                    Math.round(currentBoss.health) + ' / ' + Math.round(currentBoss.maxHealth);
            }
        }

        function checkLevelUp() {
            if (playerStats.xp >= playerStats.xpNeeded) {
                playerStats.xp -= playerStats.xpNeeded;
                playerStats.level++;
                playerStats.xpNeeded = Math.floor(playerStats.xpNeeded * 1.4);
                gameState = 'levelup';
                playSound('levelup', 1, 1.3);
                showLevelUpScreen();
            }
        }

        function showLevelUpScreen() {
            const upgrades = [
                { name: '‚öîÔ∏è Orbiting Sword', desc: '+1 Spinning Blade that orbits around you', 
                  apply: () => playerStats.orbitingSwords += 1 },
                { name: 'üî• Fire Tornado', desc: 'Summon a destructive whirlwind of fire', 
                  apply: () => playerStats.fireTornado = true },
                { name: '‚ö° Lightning Chain', desc: 'Chain lightning between multiple enemies', 
                  apply: () => playerStats.lightningChain = true },
                { name: 'üåä Multishot', desc: '+2 Additional projectiles per attack', 
                  apply: () => playerStats.projectileCount += 2 },
                { name: 'üíé Crit Master', desc: '+12% Critical Chance and +0.8x Damage', 
                  apply: () => { playerStats.critChance += 0.12; playerStats.critMultiplier += 0.8; } },
                { name: '‚ù§Ô∏è Titan Heart', desc: '+30 Maximum Health and full heal', 
                  apply: () => { playerStats.maxHealth += 30; playerStats.health = playerStats.maxHealth; } },
                { name: '‚ö° Rapid Fire', desc: '-25% Attack cooldown for faster shooting', 
                  apply: () => playerStats.attackSpeed *= 0.75 },
                { name: 'üíÄ Devastation', desc: '+18 Base damage to all attacks', 
                  apply: () => playerStats.damage += 18 },
                { name: 'üèÉ Speed Demon', desc: '+1.5 Movement speed', 
                  apply: () => playerStats.speed += 1.5 }
            ];

            // Show 3 regular upgrades
            const shuffled = upgrades.sort(() => Math.random() - 0.5).slice(0, 3);
            const container = document.getElementById('upgradeOptions');
            container.innerHTML = '';

            shuffled.forEach(upgrade => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `
                    <div class="upgrade-title">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                `;
                div.onclick = () => {
                    upgrade.apply();
                    updateUI();
                    updateHealthBar();
                    updateHotbar();
                    document.getElementById('levelUpScreen').style.display = 'none';
                    gameState = 'playing';
                    playSound('ability', 1.2, 1);
                    addScreenShake(10);
                };
                container.appendChild(div);
            });

            document.getElementById('levelUpScreen').style.display = 'flex';
        }

        function showNotification(text, color = '#ffd700') {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.style.color = color;
            notif.style.opacity = '1';
            notif.style.transform = 'translate(-50%, -50%) scale(1.2)';
            
            setTimeout(() => {
                notif.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 150);
            
            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transform = 'translate(-50%, -50%) scale(0.8)';
            }, 2500);
        }

        function showShop() {
            showShopTab('upgrades');
            document.getElementById('shopMenu').style.display = 'flex';
            updateTotalKillsDisplay();
        }

        function showShopTab(tab) {
            document.getElementById('upgradesTab').classList.remove('active');
            document.getElementById('skinsTab').classList.remove('active');
            
            if (tab === 'upgrades') {
                document.getElementById('upgradesTab').classList.add('active');
                showShopUpgrades();
            } else {
                document.getElementById('skinsTab').classList.add('active');
                showShopSkins();
            }
        }

        function showShopUpgrades() {
            const container = document.getElementById('shopContent');
            container.innerHTML = '';
            
            const upgrades = [
                { 
                    name: 'üöÄ Speed Boost', 
                    desc: '+0.1 Permanent starting speed',
                    cost: 50,
                    key: 'startingSpeed',
                    max: 10
                },
                { 
                    name: '‚ù§Ô∏è Health Boost', 
                    desc: '+25 Permanent starting health',
                    cost: 75,
                    key: 'startingHealth',
                    max: 8
                },
                { 
                    name: '‚öîÔ∏è Damage Boost', 
                    desc: '+10 Permanent starting damage',
                    cost: 100,
                    key: 'startingDamage',
                    max: 10
                },
                { 
                    name: 'ü©π Regen Boost', 
                    desc: '+0.1 Permanent health regeneration',
                    cost: 60,
                    key: 'startingRegen',
                    max: 10
                }
            ];

            upgrades.forEach(upgrade => {
                const owned = persistentData.permanentUpgrades[upgrade.key];
                const canBuy = persistentData.totalKills >= upgrade.cost && owned < upgrade.max;
                
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (!canBuy) div.style.opacity = '0.5';
                div.innerHTML = `
                    <div class="shop-title">${upgrade.name}</div>
                    <div class="shop-desc">${upgrade.desc}</div>
                    <div class="shop-cost">üí∞ ${upgrade.cost} Kills</div>
                    <div class="shop-owned">Owned: ${owned}/${upgrade.max}</div>
                `;
                
                if (canBuy) {
                    div.style.cursor = 'pointer';
                    div.onclick = () => {
                        persistentData.totalKills -= upgrade.cost;
                        persistentData.permanentUpgrades[upgrade.key]++;
                        savePersistentData();
                        playSound('ability', 1.5, 1);
                        showNotification('UPGRADE PURCHASED!', '#00ff00');
                        showShopUpgrades();
                    };
                } else {
                    div.style.cursor = 'not-allowed';
                }
                
                container.appendChild(div);
            });
        }

        function showShopSkins() {
            const container = document.getElementById('shopContent');
            container.innerHTML = '';
            
            Object.keys(SKINS).forEach(skinId => {
                const skin = SKINS[skinId];
                const owned = persistentData.ownedSkins.includes(skinId);
                const equipped = persistentData.selectedSkin === skinId;
                const canBuy = persistentData.totalKills >= skin.cost && !owned;
                
                const div = document.createElement('div');
                div.className = 'shop-item';
                if (!canBuy && !owned) div.style.opacity = '0.5';
                if (equipped) div.style.border = '6px solid #00ff00';
                
                div.innerHTML = `
                    <div class="shop-title">${skin.name}</div>
                    <div class="skin-preview-container">
                        <div style="width:60px;height:60px;background:${skin.armor};border-radius:50%;border:4px solid ${skin.accent};box-shadow:0 0 20px ${skin.accent};"></div>
                    </div>
                    ${!owned ? `<div class="shop-cost">üí∞ ${skin.cost} Kills</div>` : ''}
                    ${owned && !equipped ? '<div class="shop-owned" style="color:#ffd700;">Click to Equip</div>' : ''}
                    ${equipped ? '<div class="shop-owned" style="color:#00ff00;">‚úÖ EQUIPPED</div>' : ''}
                `;
                
                if (canBuy) {
                    div.style.cursor = 'pointer';
                    div.onclick = () => {
                        persistentData.totalKills -= skin.cost;
                        persistentData.ownedSkins.push(skinId);
                        persistentData.selectedSkin = skinId;
                        savePersistentData();
                        playSound('ability', 1.8, 1.2);
                        showNotification('SKIN UNLOCKED!', '#00ff00');
                        showShopSkins();
                    };
                } else if (owned && !equipped) {
                    div.style.cursor = 'pointer';
                    div.onclick = () => {
                        persistentData.selectedSkin = skinId;
                        savePersistentData();
                        playSound('ability', 1.5, 0.8);
                        showNotification('SKIN EQUIPPED!', '#ffd700');
                        showShopSkins();
                    };
                } else if (!owned) {
                    div.style.cursor = 'not-allowed';
                }
                
                container.appendChild(div);
            });
        }

        // ==================== MAIN GAME LOOP ====================
        
        function gameLoop() {
            if (gameState !== 'playing') {
                requestAnimationFrame(gameLoop);
                return;
            }

            const currentTime = Date.now();
            const deltaTime = Math.min(currentTime - lastTime, 33);
            lastTime = currentTime;

            updateFPS();
            updateScreenShake();
            
            applyMotionBlur();
            
            drawBackground();

            accumulatedTime += deltaTime;
            if (accumulatedTime >= 1000) {
                gameTime++;
                updateUI();
                accumulatedTime -= 1000;
            }

            player.update(deltaTime);
            player.draw();

            // Auto-attack when space is pressed (for mobile shoot button)
            const now = Date.now();
            if ((now - lastAttackTime > playerStats.attackSpeed) || keys[' ']) {
                shootAtNearestEnemy();
                lastAttackTime = now;
            }

            updateAbilities(deltaTime);

            if (waveEnemiesSpawned < waveEnemiesTotal && !(wave % 5 === 0 || wave % 10 === 0)) {
                if (Math.random() < 0.06) {
                    spawnEnemy();
                }
            }

            // Update and draw projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.update(deltaTime);
                proj.draw();

                // Remove if out of bounds
                if (proj.x < -100 || proj.x > canvas.width + 100 ||
                    proj.y < -100 || proj.y > canvas.height + 100) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (proj.hitEnemies.includes(j)) continue;
                    
                    const enemy = enemies[j];
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < enemy.size + proj.size) {
                        enemy.health -= proj.damage;
                        playSound('hit', 0.8 + Math.random() * 0.2, 0.4);
                        addScreenShake(proj.crit ? 10 : 5);
                        
                        proj.hitEnemies.push(j);
                        enemy.hitTimer = 10;
                        
                        if (proj.crit) {
                            showNotification('CRITICAL!', '#ffff00');
                        }
                        
                        if (enemy.health <= 0) {
                            playSound('death', 0.7, 0.9);
                            addScreenShake(enemy.isBoss ? 35 : 10);
                            
                            const xpAmount = enemy.isBoss ? 30 : enemy.type === 'miniboss' ? 15 : 3;
                            for (let k = 0; k < xpAmount; k++) {
                                xpOrbs.push(new XPOrb(
                                    enemy.x + (Math.random() - 0.5) * enemy.size,
                                    enemy.y + (Math.random() - 0.5) * enemy.size,
                                    enemy.isBoss ? 5 : enemy.type === 'miniboss' ? 3 : 1
                                ));
                            }
                            
                            if (enemy.isBoss) {
                                currentBoss = null;
                                hideBossUI();
                                if (enemy.type === 'boss') {
                                    showNotification('BOSS DEFEATED!', '#ff0000');
                                } else {
                                    showNotification('MINI-BOSS SLAIN!', '#ff00ff');
                                }
                            }
                            
                            enemies.splice(j, 1);
                            kills++;
                            persistentData.totalKills++;
                            updateUI();
                        } else if (enemy.isBoss) {
                            updateBossHealth();
                        }
                        
                        if (proj.piercing <= 0) {
                            projectiles.splice(i, 1);
                            break;
                        } else {
                            proj.piercing--;
                        }
                    }
                }
            }

            // Update and draw enemies
            for (let enemy of enemies) {
                enemy.update(deltaTime);
                enemy.draw();
            }

            // Update and draw XP orbs
            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                if (xpOrbs[i].update(deltaTime)) {
                    xpOrbs.splice(i, 1);
                } else {
                    xpOrbs[i].draw();
                }
            }

            // Update and draw particles
            const activeParticles = particlePool.active;
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const p = activeParticles[i];
                p.x += p.vx * deltaTime / 16;
                p.y += p.vy * deltaTime / 16;
                p.life -= p.decay * deltaTime / 16;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                if (p.life <= 0) {
                    particlePool.release(p);
                } else {
                    const screenX = p.x + screenShake.x;
                    const screenY = p.y + screenShake.y;
                    
                    ctx.globalAlpha = p.life * 0.8 * gameSettings.visualEffects;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 12 * gameSettings.visualEffects;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            }

            // Check wave completion
            if (waveEnemiesSpawned >= waveEnemiesTotal && enemies.length === 0 && gameState === 'playing') {
                timeSinceWaveComplete++;
                if (timeSinceWaveComplete === 1) {
                    showNotification('WAVE CLEARED!', '#00ff88');
                    playSound('levelup', 1.5, 0.4);
                }
                if (timeSinceWaveComplete > 120) {
                    wave++;
                    updateUI();
                    spawnWave();
                }
            }

            // Check game over
            if (playerStats.health <= 0) {
                gameState = 'gameover';
                persistentData.totalKills += kills;
                savePersistentData();
                
                document.getElementById('finalWave').textContent = wave;
                document.getElementById('finalKills').textContent = kills;
                document.getElementById('finalLevel').textContent = playerStats.level;
                document.getElementById('gameOver').style.display = 'flex';
            }

            requestAnimationFrame(gameLoop);
        }

        // ==================== EVENT LISTENERS ====================
        
        // FIXED: Make sure event listeners are properly attached
        function setupEventListeners() {
            // Settings sliders
            document.getElementById('audioSlider').addEventListener('input', function() {
                document.getElementById('audioValue').textContent = this.value + '%';
            });

            document.getElementById('blurSlider').addEventListener('input', function() {
                document.getElementById('blurValue').textContent = this.value + '%';
            });

            document.getElementById('effectsSlider').addEventListener('input', function() {
                document.getElementById('effectsValue').textContent = this.value + '%';
            });

            document.getElementById('applySettings').addEventListener('click', function() {
                gameSettings.audioVolume = document.getElementById('audioSlider').value / 100;
                gameSettings.motionBlur = document.getElementById('blurSlider').value / 100;
                gameSettings.visualEffects = document.getElementById('effectsSlider').value / 100;
                
                updateSettingsDisplay();
                saveSettings();
                document.getElementById('settingsMenu').style.display = 'none';
                showNotification('SETTINGS APPLIED!', '#00ff00');
            });

            document.getElementById('closeSettings').addEventListener('click', function() {
                document.getElementById('settingsMenu').style.display = 'none';
            });

            function showSettings() {
                document.getElementById('settingsMenu').style.display = 'block';
            }

            document.getElementById('startBtn').addEventListener('click', () => {
                if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                document.getElementById('startScreen').style.display = 'none';
                initGame();
                spawnWave();
                gameState = 'playing';
                gameLoop();
            });

            document.getElementById('shopBtn').addEventListener('click', () => {
                showShop();
                document.getElementById('startScreen').style.display = 'none';
            });

            document.getElementById('settingsBtn').addEventListener('click', showSettings);
            document.getElementById('settingsFromPauseBtn').addEventListener('click', showSettings);

            document.getElementById('resumeBtn').addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                gameState = 'playing';
            });

            document.getElementById('shopFromPauseBtn').addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                showShop();
            });

            document.getElementById('mainMenuBtn').addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
                gameState = 'start';
            });

            document.getElementById('upgradesTab').addEventListener('click', () => {
                showShopTab('upgrades');
            });

            document.getElementById('skinsTab').addEventListener('click', () => {
                showShopTab('skins');
            });

            document.getElementById('closeShopBtn').addEventListener('click', () => {
                document.getElementById('shopMenu').style.display = 'none';
                if (gameState === 'paused') {
                    document.getElementById('pauseMenu').style.display = 'flex';
                } else {
                    document.getElementById('startScreen').style.display = 'flex';
                }
            });

            document.getElementById('restartBtn').addEventListener('click', () => {
                document.getElementById('gameOver').style.display = 'none';
                initGame();
                spawnWave();
                gameState = 'playing';
            });

            document.getElementById('menuBtn').addEventListener('click', () => {
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
                gameState = 'start';
            });

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (e.key.toLowerCase() === 'p' && gameState === 'playing') {
                    gameState = 'paused';
                    document.getElementById('pauseMenu').style.display = 'flex';
                }
                
                if (gameState === 'playing') {
                    if (e.key === '1' && playerStats.fireTornado && abilityCooldowns.fireTornado <= 0) {
                        abilityCooldowns.fireTornado = 1;
                    } else if (e.key === '2' && playerStats.lightningChain && abilityCooldowns.lightningChain <= 0) {
                        abilityCooldowns.lightningChain = 1;
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Touch events for mobile - make sure they don't interfere with UI buttons
            document.addEventListener('touchstart', (e) => {
                // Only prevent default if it's not a UI button
                if (e.target.tagName !== 'BUTTON' && 
                    e.target.tagName !== 'INPUT' && 
                    !e.target.classList.contains('upgrade-option') &&
                    !e.target.classList.contains('shop-item') &&
                    !e.target.classList.contains('curse-option') &&
                    !e.target.classList.contains('tab-button')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Prevent right-click menu
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        // ==================== INITIALIZATION ====================
        
        // Initialize everything
        loadPersistentData();
        loadSettings();
        initAudio();
        setupEventListeners(); // FIXED: Call this to set up event listeners
        
        // Start the game loop
        gameLoop();
        
        // Show start screen initially
        document.getElementById('startScreen').style.display = 'flex';
    </script>
</body>
</html>
